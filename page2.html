<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>小车运动动态模拟优化版</title>
    <!-- 引入 Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 引入 Font Awesome -->
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#4F46E5',
                        secondary: '#06B6D4',
                        accent: '#F59E0B',
                        success: '#10B981',
                        warning: '#F59E0B',
                        danger: '#EF4444',
                        neutral: {
                            100: '#F3F4F6',
                            200: '#E5E7EB',
                            300: '#D1D5DB',
                            400: '#9CA3AF',
                            500: '#6B7280',
                            600: '#4B5563',
                            700: '#374151',
                            800: '#1F2937',
                            900: '#111827',
                        }
                    },
                    fontFamily: {
                        inter: ['Inter', 'system-ui', 'sans-serif'],
                    },
                }
            }
        }
    </script>

    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .card-shadow {
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            }
            .card-shadow-hover {
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.12);
                transform: translateY(-2px);
            }
            .transition-all-300 {
                transition: all 0.3s ease;
            }
            .text-balance {
                text-wrap: balance;
            }
            .canvas-container {
                position: relative;
                aspect-ratio: 2/1;
                max-width: 100%;
            }
            .control-panel {
                display: flex;
                flex-direction: column;
                gap: 1rem;
            }
            .flex-grow-1 {
                flex-grow: 1;
            }
            @media (max-width: 768px) {
                .canvas-and-controls {
                    flex-direction: column;
                }
            }
            .mobile-drawing-hint {
                display: none;
            }
            @media (max-width: 600px) {
                .mobile-drawing-hint {
                    display: block;
                }
                .desktop-drawing-hint {
                    display: none;
                }
                .param-item {
                    padding: 0.8rem;
                }
                .param-label {
                    font-size: 0.9rem;
                }
                input {
                    padding: 0.6rem 0.8rem;
                }
                button {
                    padding: 0.8rem 1.2rem;
                }
            }
            /* 新增图表容器样式 */
            .chart-container {
                position: relative;
                height: 300px;
                max-width: 100%;
            }
        }
    </style>

    <style>
        body {
            background: linear-gradient(135deg, #f8fafc, #e2e8f0);
            font-family: 'Inter', system-ui, sans-serif;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 1rem;
        }

        .module {
            background-color: #ffffff;
            border-radius: 16px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            margin-bottom: 1.5rem;
            padding: 1.5rem;
            transition: all 0.3s ease;
        }

        .module:hover {
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.12);
            transform: translateY(-2px);
        }

        h1 {
            color: #111827;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.05);
            font-size: 2.5rem;
            margin-bottom: 1.5rem;
            text-align: center;
            font-weight: 600;
        }

        h2 {
            color: #374151;
            font-size: 1.8rem;
            margin-bottom: 1rem;
            text-align: center;
            font-weight: 500;
        }

        button {
            transition: all 0.3s ease;
            padding: 0.7rem 1.2rem;
            border-radius: 8px;
            font-weight: 500;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.15);
        }

        button i {
            margin-right: 0.5rem;
        }

        canvas {
            border: none;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.06);
            background-color: #f9fafb;
            width: 100%;
            height: 100%;
            transition: all 0.3s ease;
            touch-action: none;
        }

        label {
            color: #4B5563;
            margin-right: 1rem;
            font-weight: 500;
        }

        input {
            transition: all 0.3s ease;
            padding: 0.7rem 1rem;
            border-radius: 8px;
            border: 1px solid #D1D5DB;
            background-color: #f9fafb;
            width: 100%;
        }

        input:focus {
            border-color: #4F46E5;
            outline: none;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.2);
        }

        #status {
            color: #6B7280;
            text-align: center;
            margin-top: 1rem;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            background-color: #f3f4f6;
        }

        .btn-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.8rem;
            margin-bottom: 1.5rem;
        }

        .param-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 1.2rem;
        }

        .param-item {
            display: flex;
            flex-direction: column;
            padding: 1rem;
            background-color: #f9fafb;
            border-radius: 12px;
            border: 1px solid #f3f4f6;
            transition: all 0.3s ease;
        }

        .param-item:hover {
            border-color: #e5e7eb;
            background-color: #f3f4f6;
        }

        .param-label {
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: #374151;
            display: flex;
            align-items: center;
        }

        .param-label i {
            margin-right: 0.5rem;
            color: #4F46E5;
        }

        .hint-card {
            background-color: #f3f4f6;
            border-radius: 12px;
            padding: 1rem;
            margin-bottom: 1.5rem;
            border-left: 4px solid #4F46E5;
            transition: all 0.3s ease;
        }

        .hint-card:hover {
            background-color: #e5e7eb;
        }

        .hint-title {
            font-weight: 600;
            color: #374151;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
        }

        .hint-title i {
            margin-right: 0.5rem;
            color: #4F46E5;
        }

        .hint-content {
            color: #6B7280;
            line-height: 1.5;
        }

        @media (max-width: 600px) {
            .param-container {
                grid-template-columns: 1fr;
            }

            h1 {
                font-size: 2rem;
            }

            h2 {
                font-size: 1.5rem;
            }

            button {
                padding: 0.6rem 1rem;
                font-size: 0.9rem;
            }

            .container {
                margin: 1rem auto;
                padding: 0.5rem;
            }

            .module {
                padding: 1rem;
                margin-bottom: 1rem;
            }

            .hint-card {
                padding: 0.8rem;
                margin-bottom: 1rem;
            }

            .hint-content {
                font-size: 0.9rem;
            }

            #status {
                padding: 0.3rem 0.8rem;
                font-size: 0.9rem;
            }

            .btn-container {
                gap: 0.5rem;
            }
        }

        /* 新增图表标题样式 */
        .chart-title {
            text-align: center;
            font-weight: 500;
            color: #4B5563;
            margin-bottom: 0.5rem;
        }

        /* 新增图表标签样式 */
        .chart-label {
            font-size: 12px;
            fill: #4B5563;
        }
    </style>
</head>

<body class="bg-gray-50 font-inter">
    <div class="container">
        <div class="flex items-center justify-center mb-6">
            <div class="w-12 h-12 rounded-full bg-primary/10 flex items-center justify-center mr-3">
                <i class="fa fa-car text-primary text-xl"></i>
            </div>
            <h1>小车运动动态模拟 - 优化版</h1>
        </div>

        <!-- 主内容区 - 两列布局 -->
        <div class="flex flex-col lg:flex-row gap-6">
            <!-- 左侧：控制面板 -->
            <div class="lg:w-1/3 control-panel">
                <!-- 控制按钮模块 -->
                <div class="module flex-grow-1">
                    <h2>模拟控制</h2>
                    <div class="btn-container">
                        <button id="start" class="bg-success hover:bg-success/90 text-white w-full">
                            <i class="fa fa-play"></i>开始
                        </button>
                        <button id="pause" class="bg-warning hover:bg-warning/90 text-white w-full">
                            <i class="fa fa-pause"></i>暂停
                        </button>
                        <button id="reset" class="bg-danger hover:bg-danger/90 text-white w-full">
                            <i class="fa fa-refresh"></i>重置
                        </button>
                        <button id="draw" class="bg-primary hover:bg-primary/90 text-white w-full">
                            <i class="fa fa-pencil"></i>绘制轨迹
                        </button>
                        <button id="clear" class="bg-neutral-500 hover:bg-neutral-600 text-white w-full">
                            <i class="fa fa-eraser"></i>清除轨迹
                        </button>
                    </div>
                </div>

                <!-- 操作提示模块 -->
                <div class="hint-card">
                    <div class="hint-title">
                        <i class="fa fa-info-circle"></i>操作指南
                    </div>
                    <div class="hint-content">
                        <ol class="list-decimal pl-5 mt-2 text-sm">
                            <li class="desktop-drawing-hint">点击"绘制轨迹"按钮，在画布上拖动鼠标绘制小车路径</li>
                            <li class="mobile-drawing-hint">点击"绘制轨迹"按钮，在画布上拖动手指绘制小车路径</li>
                            <li>调整PID参数以优化小车的运动性能</li>
                            <li>点击"开始"按钮启动模拟</li>
                            <li>使用"暂停"和"重置"按钮控制模拟过程</li>
                            <li>观察偏差图表了解小车跟踪精度</li>
                        </ol>
                    </div>
                </div>

                <!-- 参数设置模块 -->
                <div class="module">
                    <div class="flex items-center justify-between mb-4">
                        <h2 class="text-left">参数设置</h2>
                        <button id="applyParams" class="bg-primary hover:bg-primary/90 text-white">
                            <i class="fa fa-check-circle"></i>应用参数
                        </button>
                    </div>

                    <div class="param-container">
                        <div class="param-item">
                            <div class="param-label">
                                <i class="fa fa-sliders"></i>比例系数(Kp)
                            </div>
                            <input type="number" id="kp" value="0.3" step="0.01"
                                class="bg-white border-gray-200 focus:border-primary">
                        </div>

                        <div class="param-item">
                            <div class="param-label">
                                <i class="fa fa-sliders"></i>积分系数(Ki)
                            </div>
                            <input type="number" id="ki" value="0.0" step="0.01"
                                class="bg-white border-gray-200 focus:border-primary">
                        </div>

                        <div class="param-item">
                            <div class="param-label">
                                <i class="fa fa-sliders"></i>微分系数(Kd)
                            </div>
                            <input type="number" id="kd" value="0.3" step="0.01"
                                class="bg-white border-gray-200 focus:border-primary">
                        </div>

                        <div class="param-item">
                            <div class="param-label">
                                <i class="fa fa-tachometer"></i>速度
                            </div>
                            <input type="number" id="speed" value="253" step="1"
                                class="bg-white border-gray-200 focus:border-primary">
                        </div>

                        <div class="param-item">
                            <div class="param-label">
                                <i class="fa fa-eye"></i>视野距离
                            </div>
                            <input type="number" id="viewDistance" value="2.5" step="0.1"
                                class="bg-white border-gray-200 focus:border-primary">
                        </div>
                    </div>
                </div>

                <!-- 参数提示模块 -->
                <div class="hint-card">
                    <div class="hint-title">
                        <i class="fa fa-lightbulb-o"></i>参数说明
                    </div>
                    <div class="hint-content">
                        <p><strong>PID控制参数:</strong></p>
                        <ul class="list-disc pl-5 mt-2 mb-3 text-sm">
                            <li><strong>Kp</strong>: 比例系数，控制响应速度</li>
                            <li><strong>Ki</strong>: 积分系数，消除稳态误差</li>
                            <li><strong>Kd</strong>: 微分系数，减少过冲和振荡</li>
                        </ul>
                        <p><strong>其他参数:</strong></p>
                        <ul class="list-disc pl-5 mt-2 text-sm">
                            <li><strong>速度</strong>: 小车运动速度</li>
                            <li><strong>视野距离</strong>: 小车能够"看到"的轨迹距离</li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- 右侧：轨迹和统计 -->
            <div class="lg:w-2/3 flex flex-col gap-6">
                <!-- 轨迹绘制模块 -->
                <div class="module">
                    <div class="flex items-center justify-between mb-4">
                        <h2 class="text-left">轨迹绘制</h2>
                        <div id="status" class="bg-neutral-100 text-neutral-600 px-3 py-2 rounded-lg">
                            请先绘制轨迹
                        </div>
                    </div>
                    <div class="canvas-container">
                        <canvas id="canvas"></canvas>
                    </div>
                </div>

                <!-- 轨迹提示模块 -->
                <div class="hint-card">
                    <div class="hint-title">
                        <i class="fa fa-map"></i>轨迹说明
                    </div>
                    <div class="hint-content">
                        <p class="text-sm">
                            <strong>绿色线:</strong> 您绘制的参考轨迹<br>
                            <strong>蓝色线:</strong> 小车实际行驶轨迹<br>
                            <strong>红色三角形:</strong> 小车当前位置<br>
                            <strong>蓝色半透明圆:</strong> 小车视野范围
                        </p>
                    </div>
                </div>

                <!-- 偏差统计模块 -->
                <div class="module">
                    <h2>偏差统计</h2>
                    <div class="chart-container">
                        <canvas id="deviationChart"></canvas>
                    </div>
                    <div class="flex justify-between text-sm text-neutral-500 mt-2 px-4">
                        <span><i class="fa fa-clock-o mr-1"></i>时间 (秒)</span>
                        <span><i class="fa fa-arrows-h mr-1"></i>偏差值 (像素)</span>
                    </div>
                </div>

                <!-- 偏差提示模块 -->
                <div class="hint-card">
                    <div class="hint-title">
                        <i class="fa fa-line-chart"></i>偏差分析
                    </div>
                    <div class="hint-content">
                        <p class="text-sm">
                            偏差曲线显示小车实际轨迹与参考轨迹之间的距离误差。
                            较低的偏差值表示更好的跟踪性能。您可以通过调整PID参数来优化跟踪精度。
                        </p>
                    </div>
                </div>
            </div>
        </div>

        <!-- 页脚 -->
        <footer class="mt-8 text-center text-neutral-500 text-sm">
            <p>© 2023 小车运动动态模拟 - 优化版 | 使用 HTML, Canvas 和 JavaScript 构建</p>
        </footer>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            function resizeCanvas(canvas, container) {
                const containerRect = container.getBoundingClientRect();
                const width = containerRect.width;
                const height = containerRect.height;

                canvas.width = width;
                canvas.height = height;

                canvas.style.width = '100%';
                canvas.style.height = '100%';
            }

            class PIDController {
                constructor(kp, ki, kd) {
                    this.kp = kp;
                    this.ki = ki;
                    this.kd = kd;
                    this.prevError = 0;
                    this.integral = 0;
                    this.dt = 0.1;
                }

                update(error) {
                    const pTerm = this.kp * error;
                    this.integral += error * this.dt;
                    const iTerm = this.ki * this.integral;
                    const dTerm = this.kd * (error - this.prevError);
                    this.prevError = error;
                    return pTerm + iTerm + dTerm;
                }

                reset() {
                    this.integral = 0;
                    this.prevError = 0;
                }
            }

            class CarSimulation {
                constructor() {
                    this.simulationRunning = false;
                    this.simulationPaused = false;
                    this.trajectoryPoints = [];
                    this.currentPosition = null;
                    this.currentDirection = 0;
                    this.pid = new PIDController(0.3, 0.0, 0.3);
                    this.currentIndex = 0;
                    this.data = [];
                    this.trajectoryX = [];
                    this.trajectoryY = [];
                    this.viewDistance = 2.5;
                    this.speed = 253;
                    this.sampleDistance = 10;
                    this.deviationData = [];
                    this.timeData = [];
                    this.currentSimulationTime = 0;
                    this.lastSampleTime = 0;
                    this.sampleInterval = 0.1;
                }

                startSimulation() {
                    if (!this.simulationRunning) {
                        if (this.data.length === 0) {
                            return { status: 'error', message: '请先绘制并保存轨迹！' };
                        }
                        this.simulationRunning = true;
                        this.simulationPaused = false;
                        this.runSimulation();
                        return { status: 'success', message: '模拟运行中' };
                    } else if (this.simulationPaused) {
                        this.simulationPaused = false;
                        return { status: 'success', message: '模拟继续运行' };
                    }
                }

                pauseSimulation() {
                    if (this.simulationRunning && !this.simulationPaused) {
                        this.simulationPaused = true;
                        return { status: 'success', message: '模拟已暂停' };
                    }
                }

                resetSimulation() {
                    this.simulationRunning = false;
                    this.simulationPaused = false;
                    this.currentIndex = 0;
                    this.pid.reset();
                    this.deviationData = [];
                    this.timeData = [];
                    this.currentSimulationTime = 0;
                    this.lastSampleTime = 0;

                    if (this.data.length > 0) {
                        this.currentPosition = [this.data[0][0], this.data[0][1]];
                        this.currentDirection = 0;
                        this.trajectoryX = [this.currentPosition[0]];
                        this.trajectoryY = [this.currentPosition[1]];
                    }
                    return { status: 'success', message: '模拟已重置' };
                }

                runSimulation() {
                    const dt = 0.1;
                    const intervalId = setInterval(() => {
                        if (this.simulationRunning && this.currentIndex < this.data.length) {
                            if (!this.simulationPaused) {
                                this.currentSimulationTime += dt;

                                const viewStartX = this.currentPosition[0];
                                const viewStartY = this.currentPosition[1];
                                const viewEndX = viewStartX + this.viewDistance;
                                const viewEndY = viewStartY + this.viewDistance;

                                let viewData = this.data.filter(point => {
                                    return point[0] >= viewStartX && point[0] < viewEndX && point[1] >= viewStartY && point[1] < viewEndY;
                                });

                                let targetPoint;
                                if (viewData.length > 0) {
                                    targetPoint = viewData[viewData.length - 1];
                                } else {
                                    if (this.currentIndex < this.data.length - 1) {
                                        targetPoint = this.data[this.currentIndex + 1];
                                    } else {
                                        clearInterval(intervalId);
                                        this.simulationRunning = false;
                                        this.simulationPaused = false;
                                        return;
                                    }
                                }

                                const dx = targetPoint[0] - this.currentPosition[0];
                                const dy = targetPoint[1] - this.currentPosition[1];
                                const targetDirection = Math.atan2(dy, dx);

                                let error = targetDirection - this.currentDirection;
                                while (error > Math.PI) {
                                    error -= 2 * Math.PI;
                                }
                                while (error < -Math.PI) {
                                    error += 2 * Math.PI;
                                }

                                const steeringAngle = this.pid.update(error);
                                this.currentDirection += steeringAngle;

                                this.currentPosition[0] += (this.speed / 10) * dt * Math.cos(this.currentDirection);
                                this.currentPosition[1] += (this.speed / 10) * dt * Math.sin(this.currentDirection);

                                this.trajectoryX.push(this.currentPosition[0]);
                                this.trajectoryY.push(this.currentPosition[1]);

                                const deviation = this.calculateDeviation(this.currentPosition);

                                if (this.currentSimulationTime - this.lastSampleTime >= this.sampleInterval) {
                                    this.deviationData.push(deviation);
                                    this.timeData.push(this.currentSimulationTime);
                                    this.lastSampleTime = this.currentSimulationTime;
                                }

                                if (Math.sqrt((this.currentPosition[0] - targetPoint[0]) ** 2 + (this.currentPosition[1] - targetPoint[1]) ** 2) < 5) {
                                    this.currentIndex++;
                                }
                            }
                        } else {
                            clearInterval(intervalId);
                            this.simulationRunning = false;
                            this.simulationPaused = false;
                        }
                    }, 0.0001 * 1000);
                }

                calculateDeviation(position) {
                    if (this.data.length === 0) return 0;

                    let minDistance = Infinity;
                    for (let i = 0; i < this.data.length; i++) {
                        const point = this.data[i];
                        const distance = Math.sqrt(
                            Math.pow(position[0] - point[0], 2) +
                            Math.pow(position[1] - point[1], 2)
                        );
                        minDistance = Math.min(minDistance, distance);
                    }

                    return minDistance;
                }

                setTrajectory(points) {
                    this.data = points;
                    if (this.data.length > 0) {
                        this.currentPosition = [this.data[0][0], this.data[0][1]];
                        this.trajectoryX = [this.currentPosition[0]];
                        this.trajectoryY = [this.currentPosition[1]];
                    }
                    return { status: 'success', message: '轨迹已设置' };
                }

                getStatus() {
                    return {
                        status: this.simulationRunning ? 'running' : 'stopped',
                        position: this.currentPosition,
                        direction: this.currentDirection,
                        trajectoryX: this.trajectoryX,
                        trajectoryY: this.trajectoryY,
                        originalTrajectory: this.data,
                        viewDistance: this.viewDistance,
                        deviationData: this.deviationData,
                        timeData: this.timeData
                    };
                }

                updateParams(params) {
                    if (params.kp !== undefined) {
                        this.pid.kp = parseFloat(params.kp);
                    }
                    if (params.ki !== undefined) {
                        this.pid.ki = parseFloat(params.ki);
                    }
                    if (params.kd !== undefined) {
                        this.pid.kd = parseFloat(params.kd);
                    }
                    if (params.speed !== undefined) {
                        this.speed = parseFloat(params.speed);
                    }
                    if (params.viewDistance !== undefined) {
                        this.viewDistance = parseFloat(params.viewDistance);
                    }
                    return { status: 'success', message: '参数已更新' };
                }
            }

            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            const deviationChart = document.getElementById('deviationChart');
            const deviationCtx = deviationChart.getContext('2d');
            const startButton = document.getElementById('start');
            const pauseButton = document.getElementById('pause');
            const resetButton = document.getElementById('reset');
            const drawButton = document.getElementById('draw');
            const clearButton = document.getElementById('clear');
            const applyParamsButton = document.getElementById('applyParams');
            const statusElement = document.getElementById('status');
            const canvasContainer = document.querySelector('.canvas-container');
            const deviationChartContainer = document.querySelector('.chart-container');

            resizeCanvas(canvas, canvasContainer);
            resizeCanvas(deviationChart, deviationChartContainer);

            window.addEventListener('resize', () => {
                resizeCanvas(canvas, canvasContainer);
                resizeCanvas(deviationChart, deviationChartContainer);
                updateStatus();
            });

            let isDrawing = false;
            let drawnPoints = [];
            let intervalId;
            const simulation = new CarSimulation();
            let originalTrajectoryImage = null;
            let combinedImage = null;
            let isFirstRun = true;
            const CAR_SIZE = 15;

            drawButton.addEventListener('click', () => {
                isDrawing = true;
                drawnPoints = [];
                statusElement.textContent = '正在绘制轨迹，请在画布上拖动鼠标或手指...';
                statusElement.className = 'bg-primary/10 text-primary px-3 py-2 rounded-lg text-center';

                canvas.addEventListener('mousedown', onDrawStart);
                canvas.addEventListener('mousemove', onDraw);
                canvas.addEventListener('mouseup', onDrawEnd);
                canvas.addEventListener('mouseleave', onDrawEnd);

                canvas.addEventListener('touchstart', onTouchStart, { passive: false });
                canvas.addEventListener('touchmove', onTouchMove, { passive: false });
                canvas.addEventListener('touchend', onTouchEnd);
                canvas.addEventListener('touchcancel', onTouchEnd);

                startButton.disabled = true;
                resetButton.disabled = true;
                drawButton.disabled = true;
                clearButton.disabled = false;

                drawButton.classList.add('bg-primary/80');
                setTimeout(() => {
                    drawButton.classList.remove('bg-primary/80');
                }, 300);
            });

            function onDrawStart(event) {
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                drawnPoints.push([x, y]);
                drawCurrentPoint(x, y);
            }

            function onDraw(event) {
                if (isDrawing) {
                    const rect = canvas.getBoundingClientRect();
                    const x = event.clientX - rect.left;
                    const y = event.clientY - rect.top;
                    if (drawnPoints.length > 0) {
                        const lastPoint = drawnPoints[drawnPoints.length - 1];
                        const distance = Math.sqrt((x - lastPoint[0]) ** 2 + (y - lastPoint[1]) ** 2);
                        if (distance < 5) {
                            return;
                        }
                    }
                    drawnPoints.push([x, y]);
                    redrawTrajectory();
                }
            }

            function onDrawEnd() {
                isDrawing = false;
                canvas.removeEventListener('mousedown', onDrawStart);
                canvas.removeEventListener('mousemove', onDraw);
                canvas.removeEventListener('mouseup', onDrawEnd);
                canvas.removeEventListener('mouseleave', onDrawEnd);

                canvas.removeEventListener('touchstart', onTouchStart);
                canvas.removeEventListener('touchmove', onTouchMove);
                canvas.removeEventListener('touchend', onTouchEnd);
                canvas.removeEventListener('touchcancel', onTouchEnd);

                if (drawnPoints.length > 1) {
                    const result = simulation.setTrajectory(drawnPoints);
                    statusElement.textContent = result.message;
                    statusElement.className = 'bg-success/10 text-success px-3 py-2 rounded-lg text-center';
                    startButton.disabled = false;
                    resetButton.disabled = false;
                    drawButton.disabled = false;

                    originalTrajectoryImage = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    combinedImage = originalTrajectoryImage;
                    isFirstRun = true;

                    clearDeviationChart();

                    canvas.classList.add('scale-101');
                    setTimeout(() => {
                        canvas.classList.remove('scale-101');
                    }, 300);
                } else {
                    statusElement.textContent = '未绘制有效轨迹，请重新绘制';
                    statusElement.className = 'bg-warning/10 text-warning px-3 py-2 rounded-lg text-center';
                    drawButton.disabled = false;
                }
            }

            function onTouchStart(event) {
                event.preventDefault();
                const touch = event.touches[0];
                const rect = canvas.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                drawnPoints.push([x, y]);
                drawCurrentPoint(x, y);
            }

            function onTouchMove(event) {
                event.preventDefault();
                if (isDrawing && event.touches.length > 0) {
                    const touch = event.touches[0];
                    const rect = canvas.getBoundingClientRect();
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;

                    if (drawnPoints.length > 0) {
                        const lastPoint = drawnPoints[drawnPoints.length - 1];
                        const distance = Math.sqrt((x - lastPoint[0]) ** 2 + (y - lastPoint[1]) ** 2);
                        if (distance < 8) {
                            return;
                        }
                    }

                    drawnPoints.push([x, y]);
                    redrawTrajectory();
                }
            }

            function onTouchEnd() {
                onDrawEnd();
            }

            function drawCurrentPoint(x, y) {
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, 2 * Math.PI);
                ctx.fillStyle = '#10B981';
                ctx.fill();
            }

            function redrawTrajectory() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.beginPath();
                ctx.moveTo(drawnPoints[0][0], drawnPoints[0][1]);
                for (let i = 1; i < drawnPoints.length; i++) {
                    ctx.lineTo(drawnPoints[i][0], drawnPoints[i][1]);
                }
                ctx.strokeStyle = '#10B981';
                ctx.lineWidth = 3;
                ctx.stroke();
            }

            clearButton.addEventListener('click', () => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawnPoints = [];
                startButton.disabled = true;
                resetButton.disabled = true;
                clearButton.disabled = true;
                statusElement.textContent = '轨迹已清除，请重新绘制';
                statusElement.className = 'bg-neutral-100 text-neutral-600 px-3 py-2 rounded-lg text-center';
                originalTrajectoryImage = null;
                combinedImage = null;
                isFirstRun = true;

                clearDeviationChart();

                canvas.classList.add('opacity-50');
                setTimeout(() => {
                    canvas.classList.remove('opacity-50');
                }, 300);
            });

            startButton.addEventListener('click', () => {
                const result = simulation.startSimulation();
                statusElement.textContent = result.message;
                statusElement.className = 'bg-success/10 text-success px-3 py-2 rounded-lg text-center';
                startButton.disabled = true;
                pauseButton.disabled = false;
                if (!intervalId) {
                    intervalId = setInterval(updateStatus, 100);
                }

                startButton.classList.add('scale-95');
                setTimeout(() => {
                    startButton.classList.remove('scale-95');
                }, 200);
            });

            pauseButton.addEventListener('click', () => {
                const result = simulation.pauseSimulation();
                statusElement.textContent = result.message;
                statusElement.className = 'bg-warning/10 text-warning px-3 py-2 rounded-lg text-center';
                startButton.disabled = false;
                pauseButton.disabled = true;

                pauseButton.classList.add('scale-95');
                setTimeout(() => {
                    pauseButton.classList.remove('scale-95');
                }, 200);
            });

            resetButton.addEventListener('click', () => {
                const result = simulation.resetSimulation();
                statusElement.textContent = result.message;
                statusElement.className = 'bg-neutral-100 text-neutral-600 px-3 py-2 rounded-lg text-center';
                startButton.disabled = false;
                pauseButton.disabled = true;
                clearInterval(intervalId);
                intervalId = null;

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                if (originalTrajectoryImage) {
                    ctx.putImageData(originalTrajectoryImage, 0, 0);
                }
                combinedImage = originalTrajectoryImage;
                isFirstRun = true;

                clearDeviationChart();

                canvas.classList.add('scale-98');
                setTimeout(() => {
                    canvas.classList.remove('scale-98');
                }, 300);
            });

            applyParamsButton.addEventListener('click', () => {
                const kp = document.getElementById('kp').value;
                const ki = document.getElementById('ki').value;
                const kd = document.getElementById('kd').value;
                const speed = document.getElementById('speed').value;
                const viewDistance = document.getElementById('viewDistance').value;

                const result = simulation.updateParams({
                    kp: kp,
                    ki: ki,
                    kd: kd,
                    speed: speed,
                    viewDistance: viewDistance
                });

                statusElement.textContent = result.message +
                    ` (Kp=${kp}, Ki=${ki}, Kd=${kd}, 速度=${speed}, 视野=${viewDistance})`;
                statusElement.className = 'bg-primary/10 text-primary px-3 py-2 rounded-lg text-center';

                applyParamsButton.classList.add('bg-primary/90');
                setTimeout(() => {
                    applyParamsButton.classList.remove('bg-primary/90');
                }, 300);
            });

            function drawCar(x, y, direction, viewDistance) {
                viewDistance = viewDistance * 8;
                ctx.beginPath();
                ctx.arc(x, y, viewDistance, 0, 2 * Math.PI);
                ctx.strokeStyle = 'rgba(79, 70, 229, 0.3)';
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.fillStyle = 'rgba(79, 70, 229, 0.1)';
                ctx.fill();

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(direction);

                ctx.beginPath();
                ctx.moveTo(CAR_SIZE, 0);
                ctx.lineTo(-CAR_SIZE / 2, CAR_SIZE / 2);
                ctx.lineTo(-CAR_SIZE / 2, -CAR_SIZE / 2);
                ctx.closePath();

                ctx.fillStyle = '#EF4444';
                ctx.fill();
                ctx.strokeStyle = '#B91C1C';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(CAR_SIZE/2, 0);
                ctx.lineTo(-CAR_SIZE / 4, CAR_SIZE / 4);
                ctx.lineTo(-CAR_SIZE / 4, -CAR_SIZE / 4);
                ctx.closePath();
                ctx.fillStyle = '#FFFFFF';
                ctx.fill();

                ctx.restore();
            }

            function updateStatus() {
                const status = simulation.getStatus();

                if (originalTrajectoryImage) {
                    ctx.putImageData(originalTrajectoryImage, 0, 0);
                }

                if (status.trajectoryX.length > 0) {
                    ctx.beginPath();
                    ctx.moveTo(status.trajectoryX[0], status.trajectoryY[0]);
                    for (let i = 1; i < status.trajectoryX.length; i++) {
                        ctx.lineTo(status.trajectoryX[i], status.trajectoryY[i]);
                    }
                    ctx.strokeStyle = '#3B82F6';
                    ctx.lineWidth = 3;
                    ctx.stroke();

                    if (status.status === 'stopped' && isFirstRun) {
                        combinedImage = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        isFirstRun = false;
                    }
                }

                if (status.position) {
                    drawCar(status.position[0], status.position[1], status.direction, status.viewDistance);
                }

                if (status.status === 'stopped' && combinedImage) {
                    ctx.putImageData(combinedImage, 0, 0);

                    if (status.position) {
                        drawCar(status.position[0], status.position[1], status.direction, status.viewDistance);
                    }
                }

                updateDeviationChart(status.deviationData, status.timeData);
            }

            // 优化后的偏差图表绘制函数
            function updateDeviationChart(deviationData, timeData) {
                deviationCtx.clearRect(0, 0, deviationChart.width, deviationChart.height);

                if (deviationData.length === 0) {
                    return;
                }

                // 增加左侧边距，给纵坐标数值留出空间
                const marginLeft = 50;  // 左侧边距增加
                const marginBottom = 30;
                const marginRight = 20;
                const marginTop = 20;

                const chartWidth = deviationChart.width - marginLeft - marginRight;
                const chartHeight = deviationChart.height - marginTop - marginBottom;

                // 计算最大值
                const maxDeviation = Math.max(...deviationData);
                const minDeviation = Math.min(...deviationData);
                const maxTime = Math.max(...timeData) || 1;

                // 绘制图表标题
                deviationCtx.fillStyle = '#374151';
                deviationCtx.font = 'bold 14px Inter';
                deviationCtx.textAlign = 'center';
                deviationCtx.fillText('小车轨迹跟踪偏差统计', deviationChart.width / 2, 15);

                // 绘制坐标轴
                deviationCtx.beginPath();
                deviationCtx.moveTo(marginLeft, marginTop);
                deviationCtx.lineTo(marginLeft, marginTop + chartHeight);
                deviationCtx.lineTo(marginLeft + chartWidth, marginTop + chartHeight);
                deviationCtx.strokeStyle = '#333';
                deviationCtx.lineWidth = 1;
                deviationCtx.stroke();

                // 绘制刻度
                const tickCount = 6;
                for (let i = 0; i <= tickCount; i++) {
                    // X轴刻度
                    const xPos = marginLeft + (i / tickCount) * chartWidth;
                    deviationCtx.beginPath();
                    deviationCtx.moveTo(xPos, marginTop + chartHeight);
                    deviationCtx.lineTo(xPos, marginTop + chartHeight + 5);
                    deviationCtx.stroke();

                    // 显示时间刻度值
                    const timeValue = (i / tickCount) * maxTime;
                    deviationCtx.fillStyle = '#4B5563';
                    deviationCtx.font = '10px Inter';
                    deviationCtx.textAlign = 'center';
                    deviationCtx.fillText(timeValue.toFixed(1), xPos, marginTop + chartHeight + 18);
                }

                // Y轴刻度和标签
                for (let i = 0; i <= 5; i++) {
                    const yPos = marginTop + chartHeight - (i / 5) * chartHeight;
                    deviationCtx.beginPath();
                    deviationCtx.moveTo(marginLeft, yPos);
                    deviationCtx.lineTo(marginLeft - 5, yPos);
                    deviationCtx.stroke();

                    const deviationValue = minDeviation + (i / 5) * (maxDeviation - minDeviation);
                    deviationCtx.fillStyle = '#4B5563';
                    deviationCtx.font = '10px Inter';
                    deviationCtx.textAlign = 'right';
                    deviationCtx.fillText(deviationValue.toFixed(1), marginLeft - 8, yPos + 3);
                }

                // 绘制单位标签
                deviationCtx.textAlign = 'center';
                deviationCtx.fillText('时间 (秒)', marginLeft + chartWidth / 2, deviationChart.height - 5);

                deviationCtx.save();
                deviationCtx.translate(10, marginTop + chartHeight / 2);
                deviationCtx.rotate(-Math.PI / 2);
                deviationCtx.textAlign = 'center';
                deviationCtx.fillText('偏差值 (像素)', 0, 0);
                deviationCtx.restore();

                // 绘制偏差曲线
                if (deviationData.length > 1) {
                    deviationCtx.beginPath();
                    deviationCtx.moveTo(
                        marginLeft + timeData[0] * (chartWidth / maxTime),
                        marginTop + chartHeight - (deviationData[0] - minDeviation) * (chartHeight / (maxDeviation - minDeviation))
                    );

                    for (let i = 1; i < deviationData.length; i++) {
                        deviationCtx.lineTo(
                            marginLeft + timeData[i] * (chartWidth / maxTime),
                            marginTop + chartHeight - (deviationData[i] - minDeviation) * (chartHeight / (maxDeviation - minDeviation))
                        );
                    }

                    deviationCtx.strokeStyle = '#EF4444';
                    deviationCtx.lineWidth = 2;
                    deviationCtx.stroke();
                }

                // 显示当前偏差值
                if (deviationData.length > 0) {
                    const lastDeviation = deviationData[deviationData.length - 1];
                    deviationCtx.fillStyle = '#111827';
                    deviationCtx.font = 'bold 12px Inter';
                    deviationCtx.textAlign = 'right';
                    deviationCtx.fillText(`当前偏差: ${lastDeviation.toFixed(2)}`, deviationChart.width - 10, 25);

                    // 显示偏差分析
                    let analysis = '';
                    let color = '#111827';
                    if (lastDeviation < 5) {
                        analysis = '跟踪精度: 优秀';
                        color = '#10B981';
                    } else if (lastDeviation < 10) {
                        analysis = '跟踪精度: 良好';
                        color = '#F59E0B';
                    } else {
                        analysis = '跟踪精度: 需优化';
                        color = '#EF4444';
                    }

                    deviationCtx.fillStyle = color;
                    deviationCtx.font = 'bold 12px Inter';
                    deviationCtx.textAlign = 'right';
                    deviationCtx.fillText(analysis, deviationChart.width - 10, 45);
                }
            }

            function clearDeviationChart() {
                deviationCtx.clearRect(0, 0, deviationChart.width, deviationChart.height);

                // 绘制坐标轴
                const marginLeft = 50;
                const marginBottom = 30;
                const marginRight = 20;
                const marginTop = 20;
                const chartWidth = deviationChart.width - marginLeft - marginRight;
                const chartHeight = deviationChart.height - marginTop - marginBottom;

                deviationCtx.beginPath();
                deviationCtx.moveTo(marginLeft, marginTop);
                deviationCtx.lineTo(marginLeft, marginTop + chartHeight);
                deviationCtx.lineTo(marginLeft + chartWidth, marginTop + chartHeight);
                deviationCtx.strokeStyle = '#333';
                deviationCtx.lineWidth = 1;
                deviationCtx.stroke();

                // 绘制标题
                deviationCtx.fillStyle = '#374151';
                deviationCtx.font = 'bold 14px Inter';
                deviationCtx.textAlign = 'center';
                deviationCtx.fillText('小车轨迹跟踪偏差统计', deviationChart.width / 2, 15);

                // 绘制单位标签
                deviationCtx.textAlign = 'center';
                deviationCtx.fillStyle = '#4B5563';
                deviationCtx.font = '10px Inter';
                deviationCtx.fillText('时间 (秒)', marginLeft + chartWidth / 2, deviationChart.height - 5);

                deviationCtx.save();
                deviationCtx.translate(10, marginTop + chartHeight / 2);
                deviationCtx.rotate(-Math.PI / 2);
                deviationCtx.textAlign = 'center';
                deviationCtx.fillText('偏差值 (像素)', 0, 0);
                deviationCtx.restore();

                // 显示提示信息
                deviationCtx.fillStyle = '#666';
                deviationCtx.font = '14px Inter';
                deviationCtx.textAlign = 'center';
                deviationCtx.fillText('模拟开始后显示偏差曲线', marginLeft + chartWidth / 2, marginTop + chartHeight / 2);
            }

            // 初始化偏差图表
            clearDeviationChart();
        });
    </script>
</body>
</html>
