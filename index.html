<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>智能小车运动模拟系统</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#3B82F6',
                        secondary: '#10B981',
                        accent: '#F59E0B',
                        dark: '#1E293B',
                        light: '#F8FAFC'
                    },
                    fontFamily: {
                        inter: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .glass {
                background: rgba(255, 255, 255, 0.25);
                backdrop-filter: blur(4px);
                -webkit-backdrop-filter: blur(4px);
                border: 1px solid rgba(255, 255, 255, 0.18);
            }
            .btn-primary {
                @apply bg-primary hover:bg-primary/90 text-white font-medium py-2 px-4 rounded-lg transition-all duration-300 shadow-md hover:shadow-lg transform hover:-translate-y-0.5;
            }
            .btn-secondary {
                @apply bg-secondary hover:bg-secondary/90 text-white font-medium py-2 px-4 rounded-lg transition-all duration-300 shadow-md hover:shadow-lg transform hover:-translate-y-0.5;
            }
            .btn-accent {
                @apply bg-accent hover:bg-accent/90 text-white font-medium py-2 px-4 rounded-lg transition-all duration-300 shadow-md hover:shadow-lg transform hover:-translate-y-0.5;
            }
            .param-card {
                @apply bg-white rounded-xl shadow-lg p-4 border border-gray-100 transition-all duration-300 hover:shadow-xl;
            }
            .status-card {
                @apply bg-white rounded-xl shadow-lg p-4 border border-gray-100 transition-all duration-300 hover:shadow-xl;
            }
        }
    </style>
</head>
<body class="bg-gradient-to-br from-blue-50 to-indigo-100 min-h-screen font-inter text-dark">
    <div class="container mx-auto px-4 py-8 max-w-7xl">
        <!-- 标题区域 -->
        <header class="mb-8 text-center">
            <h1 class="text-[clamp(2rem,5vw,3rem)] font-bold text-transparent bg-clip-text bg-gradient-to-r from-primary to-indigo-600 mb-2">智能小车运动模拟系统</h1>
            <p class="text-gray-600 max-w-2xl mx-auto">基于PD控制算法的轨迹跟踪仿真平台，可自定义轨迹和控制参数</p>
        </header>

        <!-- 主内容区域 -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            <!-- 控制面板 -->
            <div class="lg:col-span-1 space-y-6">
                <!-- 操作按钮组 -->
                <div class="param-card">
                    <h2 class="text-xl font-semibold mb-4 flex items-center">
                        <i class="fa fa-sliders text-primary mr-2"></i>操作控制
                    </h2>
                    <div class="grid grid-cols-2 gap-3">
                        <button id="start" class="btn-primary flex items-center justify-center">
                            <i class="fa fa-play mr-2"></i>开始
                        </button>
                        <button id="pause" class="btn-accent flex items-center justify-center">
                            <i class="fa fa-pause mr-2"></i>暂停
                        </button>
                        <button id="reset" class="btn-accent flex items-center justify-center">
                            <i class="fa fa-refresh mr-2"></i>重置
                        </button>
                        <button id="draw" class="btn-secondary flex items-center justify-center">
                            <i class="fa fa-pencil mr-2"></i>绘制轨迹
                        </button>
                        <button id="clear" class="btn-accent flex items-center justify-center">
                            <i class="fa fa-eraser mr-2"></i>清除轨迹
                        </button>
                        <button id="applyParams" class="btn-primary flex items-center justify-center">
                            <i class="fa fa-check mr-2"></i>应用参数
                        </button>
                    </div>
                </div>

                <!-- 参数设置 -->
                <div class="param-card">
                    <h2 class="text-xl font-semibold mb-4 flex items-center">
                        <i class="fa fa-cog text-primary mr-2"></i>参数设置
                    </h2>
                    <div class="space-y-4">
                        <div class="param-group">
                            <label for="kp" class="block text-sm font-medium text-gray-700 mb-1">比例系数(Kp):</label>
                            <div class="flex items-center">
                                <input type="range" id="kpRange" min="0" max="2" step="0.01" value="0.3"
                                    class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-primary">
                                <input type="number" id="kp" value="0.3" step="0.01"
                                    class="w-20 ml-2 px-3 py-1 border border-gray-300 rounded-md text-center">
                            </div>
                            <div class="flex justify-between text-xs text-gray-500 mt-1">
                                <span>0</span>
                                <span>1</span>
                                <span>2</span>
                            </div>
                        </div>

                        <div class="param-group">
                            <label for="kd" class="block text-sm font-medium text-gray-700 mb-1">微分系数(Kd):</label>
                            <div class="flex items-center">
                                <input type="range" id="kdRange" min="0" max="2" step="0.01" value="0.3"
                                    class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-primary">
                                <input type="number" id="kd" value="0.3" step="0.01"
                                    class="w-20 ml-2 px-3 py-1 border border-gray-300 rounded-md text-center">
                            </div>
                            <div class="flex justify-between text-xs text-gray-500 mt-1">
                                <span>0</span>
                                <span>1</span>
                                <span>2</span>
                            </div>
                        </div>

                        <div class="param-group">
                            <label for="speed" class="block text-sm font-medium text-gray-700 mb-1">速度:</label>
                            <div class="flex items-center">
                                <input type="range" id="speedRange" min="100" max="500" step="1" value="253"
                                    class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-primary">
                                <input type="number" id="speed" value="253" step="1"
                                    class="w-20 ml-2 px-3 py-1 border border-gray-300 rounded-md text-center">
                            </div>
                            <div class="flex justify-between text-xs text-gray-500 mt-1">
                                <span>100</span>
                                <span>300</span>
                                <span>500</span>
                            </div>
                        </div>

                        <div class="param-group">
                            <label for="viewDistance" class="block text-sm font-medium text-gray-700 mb-1">视野距离:</label>
                            <div class="flex items-center">
                                <input type="range" id="viewDistanceRange" min="0.5" max="5" step="0.1" value="2.5"
                                    class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-primary">
                                <input type="number" id="viewDistance" value="2.5" step="0.1"
                                    class="w-20 ml-2 px-3 py-1 border border-gray-300 rounded-md text-center">
                            </div>
                            <div class="flex justify-between text-xs text-gray-500 mt-1">
                                <span>0.5</span>
                                <span>3</span>
                                <span>5</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 状态信息 -->
                <div class="status-card">
                    <h2 class="text-xl font-semibold mb-4 flex items-center">
                        <i class="fa fa-info-circle text-primary mr-2"></i>状态信息
                    </h2>
                    <div class="space-y-3">
                        <div class="flex justify-between items-center p-3 bg-gray-50 rounded-lg">
                            <span class="text-gray-600">系统状态:</span>
                            <span id="systemStatus" class="font-medium">准备就绪</span>
                        </div>
                        <div class="grid grid-cols-2 gap-3">
                            <div class="p-3 bg-gray-50 rounded-lg">
                                <div class="text-xs text-gray-500 mb-1">当前位置</div>
                                <div id="currentPosition" class="font-medium">--, --</div>
                            </div>
                            <div class="p-3 bg-gray-50 rounded-lg">
                                <div class="text-xs text-gray-500 mb-1">行驶方向</div>
                                <div id="currentDirection" class="font-medium">0°</div>
                            </div>
                        </div>
                        <div class="p-3 bg-gray-50 rounded-lg">
                            <div class="text-xs text-gray-500 mb-1">轨迹完成度</div>
                            <div class="w-full bg-gray-200 rounded-full h-2.5">
                                <div id="progressBar" class="bg-primary h-2.5 rounded-full" style="width: 0%"></div>
                            </div>
                            <div class="flex justify-between text-xs text-gray-500 mt-1">
                                <span id="progressText">0%</span>
                                <span>100%</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 画布区域 -->
            <div class="lg:col-span-2">
                <div class="bg-white rounded-xl shadow-lg overflow-hidden border border-gray-100 transition-all duration-300 hover:shadow-xl">
                    <div class="p-4 bg-gray-50 border-b border-gray-200 flex justify-between items-center">
                        <h2 class="text-xl font-semibold flex items-center">
                            <i class="fa fa-area-chart text-primary mr-2"></i>仿真画布
                        </h2>
                        <div class="flex items-center space-x-2">
                            <span class="text-xs text-gray-500">小车位置</span>
                            <span class="w-3 h-3 rounded-full bg-red-500"></span>
                            <span class="text-xs text-gray-500 ml-2">目标轨迹</span>
                            <span class="w-3 h-3 rounded-full bg-green-500"></span>
                            <span class="text-xs text-gray-500 ml-2">实际轨迹</span>
                            <span class="w-3 h-3 rounded-full bg-blue-500"></span>
                        </div>
                    </div>
                    <div class="p-4">
                        <canvas id="canvas" class="w-full rounded-lg border border-gray-200 shadow-sm"></canvas>
                        <p id="status" class="mt-3 text-center text-gray-600">请先绘制轨迹</p>
                    </div>
                </div>

                <!-- 仿真说明 -->
                <div class="mt-6 bg-white rounded-xl shadow-lg p-6 border border-gray-100 transition-all duration-300 hover:shadow-xl">
                    <h2 class="text-xl font-semibold mb-4 flex items-center">
                        <i class="fa fa-book text-primary mr-2"></i>仿真说明
                    </h2>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div class="p-4 bg-blue-50 rounded-lg border border-blue-100">
                            <h3 class="font-medium text-blue-800 mb-2 flex items-center">
                                <i class="fa fa-lightbulb-o mr-2"></i>如何使用
                            </h3>
                            <ul class="text-sm text-blue-700 space-y-2">
                                <li class="flex items-start">
                                    <i class="fa fa-check-circle text-blue-500 mt-1 mr-2"></i>
                                    <span>点击"绘制轨迹"按钮在画布上绘制路径</span>
                                </li>
                                <li class="flex items-start">
                                    <i class="fa fa-check-circle text-blue-500 mt-1 mr-2"></i>
                                    <span>调整参数以优化小车的轨迹跟踪性能</span>
                                </li>
                                <li class="flex items-start">
                                    <i class="fa fa-check-circle text-blue-500 mt-1 mr-2"></i>
                                    <span>点击"开始"按钮启动仿真</span>
                                </li>
                                <li class="flex items-start">
                                    <i class="fa fa-check-circle text-blue-500 mt-1 mr-2"></i>
                                    <span>使用"暂停"和"重置"按钮控制仿真过程</span>
                                </li>
                            </ul>
                        </div>
                        <div class="p-4 bg-green-50 rounded-lg border border-green-100">
                            <h3 class="font-medium text-green-800 mb-2 flex items-center">
                                <i class="fa fa-cogs mr-2"></i>参数说明
                            </h3>
                            <ul class="text-sm text-green-700 space-y-2">
                                <li class="flex items-start">
                                    <i class="fa fa-info-circle text-green-500 mt-1 mr-2"></i>
                                    <span><strong>Kp (比例系数)</strong>: 调整响应速度</span>
                                </li>
                                <li class="flex items-start">
                                    <i class="fa fa-info-circle text-green-500 mt-1 mr-2"></i>
                                    <span><strong>Kd (微分系数)</strong>: 减少系统振荡</span>
                                </li>
                                <li class="flex items-start">
                                    <i class="fa fa-info-circle text-green-500 mt-1 mr-2"></i>
                                    <span><strong>速度</strong>: 控制小车移动速度</span>
                                </li>
                                <li class="flex items-start">
                                    <i class="fa fa-info-circle text-green-500 mt-1 mr-2"></i>
                                    <span><strong>视野距离</strong>: 决定小车的前瞻距离</span>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 页脚 -->
        <footer class="mt-12 text-center text-gray-500 text-sm">
            <p>© 2025 智能小车运动模拟系统 | 基于PD控制算法的轨迹跟踪仿真平台</p>
        </footer>
    </div>

    <script>
        // 滑块与输入框联动
        document.getElementById('kpRange').addEventListener('input', function() {
            document.getElementById('kp').value = this.value;
        });
        document.getElementById('kp').addEventListener('input', function() {
            document.getElementById('kpRange').value = this.value;
        });

        document.getElementById('kdRange').addEventListener('input', function() {
            document.getElementById('kd').value = this.value;
        });
        document.getElementById('kd').addEventListener('input', function() {
            document.getElementById('kdRange').value = this.value;
        });

        document.getElementById('speedRange').addEventListener('input', function() {
            document.getElementById('speed').value = this.value;
        });
        document.getElementById('speed').addEventListener('input', function() {
            document.getElementById('speedRange').value = this.value;
        });

        document.getElementById('viewDistanceRange').addEventListener('input', function() {
            document.getElementById('viewDistance').value = this.value;
        });
        document.getElementById('viewDistance').addEventListener('input', function() {
            document.getElementById('viewDistanceRange').value = this.value;
        });

        // PD 控制器类
        class PDController {
            constructor(kp, kd) {
                this.kp = kp;
                this.kd = kd;
                this.prevError = 0;
            }

            update(error) {
                const pTerm = this.kp * error;
                const dTerm = this.kd * (error - this.prevError);
                this.prevError = error;
                return pTerm + dTerm;
            }
        }

        // 小车模拟类
        class CarSimulation {
            constructor() {
                this.simulationRunning = false;
                this.simulationPaused = false;
                this.trajectoryPoints = [];
                this.currentPosition = null;
                this.currentDirection = 0;
                this.pd = new PDController(0.3, 0.3);
                this.currentIndex = 0;
                this.data = [];
                this.trajectoryX = [];
                this.trajectoryY = [];
                this.viewDistance = 2.5; // 视野距离
                this.speed = 253;
                this.sampleDistance = 10;
            }

            startSimulation() {
                if (!this.simulationRunning) {
                    if (this.data.length === 0) {
                        return { status: 'error', message: '请先绘制并保存轨迹！' };
                    }
                    this.simulationRunning = true;
                    this.simulationPaused = false;
                    this.runSimulation();
                    return { status: 'success', message: '模拟运行中' };
                } else if (this.simulationPaused) {
                    this.simulationPaused = false;
                    return { status: 'success', message: '模拟继续运行' };
                }
            }

            pauseSimulation() {
                if (this.simulationRunning && !this.simulationPaused) {
                    this.simulationPaused = true;
                    return { status: 'success', message: '模拟已暂停' };
                }
            }

            resetSimulation() {
                this.simulationRunning = false;
                this.simulationPaused = false;
                this.currentIndex = 0;
                if (this.data.length > 0) {
                    this.currentPosition = [this.data[0][0], this.data[0][1]];
                    this.currentDirection = 0;
                    this.trajectoryX = [this.currentPosition[0]];
                    this.trajectoryY = [this.currentPosition[1]];
                    this.pd.prevError = 0;
                }
                return { status: 'success', message: '模拟已重置' };
            }

            runSimulation() {
                const dt = 0.1;
                const intervalId = setInterval(() => {
                    if (this.simulationRunning && this.currentIndex < this.data.length) {
                        if (!this.simulationPaused) {
                            const viewStartX = this.currentPosition[0];
                            const viewStartY = this.currentPosition[1];
                            const viewEndX = viewStartX + this.viewDistance;
                            const viewEndY = viewStartY + this.viewDistance;

                            let viewData = this.data.filter(point => {
                                return point[0] >= viewStartX && point[0] < viewEndX && point[1] >= viewStartY && point[1] < viewEndY;
                            });

                            let targetPoint;
                            if (viewData.length > 0) {
                                targetPoint = viewData[viewData.length - 1];
                            } else {
                                if (this.currentIndex < this.data.length - 1) {
                                    targetPoint = this.data[this.currentIndex + 1];
                                } else {
                                    clearInterval(intervalId);
                                    this.simulationRunning = false;
                                    this.simulationPaused = false;
                                    return;
                                }
                            }

                            const dx = targetPoint[0] - this.currentPosition[0];
                            const dy = targetPoint[1] - this.currentPosition[1];
                            const targetDirection = Math.atan2(dy, dx);

                            let error = targetDirection - this.currentDirection;
                            while (error > Math.PI) {
                                error -= 2 * Math.PI;
                            }
                            while (error < -Math.PI) {
                                error += 2 * Math.PI;
                            }

                            const steeringAngle = this.pd.update(error);
                            this.currentDirection += steeringAngle;

                            this.currentPosition[0] += (this.speed / 10) * dt * Math.cos(this.currentDirection);
                            this.currentPosition[1] += (this.speed / 10) * dt * Math.sin(this.currentDirection);

                            this.trajectoryX.push(this.currentPosition[0]);
                            this.trajectoryY.push(this.currentPosition[1]);

                            if (Math.sqrt((this.currentPosition[0] - targetPoint[0]) ** 2 + (this.currentPosition[1] - targetPoint[1]) ** 2) < 5) {
                                this.currentIndex++;
                            }
                        }
                    } else {
                        clearInterval(intervalId);
                        this.simulationRunning = false;
                        this.simulationPaused = false;
                    }
                }, 0.0001 * 1000);
            }

            setTrajectory(points) {
                this.data = points;
                if (this.data.length > 0) {
                    this.currentPosition = [this.data[0][0], this.data[0][1]];
                    this.trajectoryX = [this.currentPosition[0]];
                    this.trajectoryY = [this.currentPosition[1]];
                }
                return { status: 'success', message: '轨迹已设置' };
            }

            getStatus() {
                const progress = this.data.length > 0 ? Math.min(100, Math.round((this.currentIndex / this.data.length) * 100)) : 0;
                return {
                    status: this.simulationRunning ? 'running' : 'stopped',
                    position: this.currentPosition,
                    direction: this.currentDirection,
                    trajectoryX: this.trajectoryX,
                    trajectoryY: this.trajectoryY,
                    originalTrajectory: this.data,
                    viewDistance: this.viewDistance,
                    progress: progress
                };
            }

            updateParams(params) {
                if (params.kp !== undefined) {
                    this.pd.kp = parseFloat(params.kp);
                }
                if (params.kd !== undefined) {
                    this.pd.kd = parseFloat(params.kd);
                }
                if (params.speed !== undefined) {
                    this.speed = parseFloat(params.speed);
                }
                if (params.viewDistance !== undefined) {
                    this.viewDistance = parseFloat(params.viewDistance);
                }
                return { status: 'success', message: '参数已更新' };
            }
        }

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const startButton = document.getElementById('start');
        const pauseButton = document.getElementById('pause');
        const resetButton = document.getElementById('reset');
        const drawButton = document.getElementById('draw');
        const clearButton = document.getElementById('clear');
        const applyParamsButton = document.getElementById('applyParams');
        const statusElement = document.getElementById('status');
        const systemStatusElement = document.getElementById('systemStatus');
        const currentPositionElement = document.getElementById('currentPosition');
        const currentDirectionElement = document.getElementById('currentDirection');
        const progressBarElement = document.getElementById('progressBar');
        const progressTextElement = document.getElementById('progressText');

        // 调整画布大小以适应容器
        function resizeCanvas() {
            const container = canvas.parentElement;
            const width = container.clientWidth;
            const height = Math.min(width * 0.75, 600);
            canvas.width = width;
            canvas.height = height;
        }

        // 初始调整大小并监听窗口变化
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        let isDrawing = false;
        let drawnPoints = [];
        let intervalId;
        const simulation = new CarSimulation();
        let originalTrajectoryImage = null;
        let combinedImage = null;
        let isFirstRun = true;
        const CAR_SIZE = 15; // 小车大小

        // 移动端支持 - 获取触摸位置
        function getTouchPosition(event) {
            const rect = canvas.getBoundingClientRect();
            if (event.touches && event.touches.length > 0) {
                return {
                    x: event.touches[0].clientX - rect.left,
                    y: event.touches[0].clientY - rect.top
                };
            }
            return null;
        }

        drawButton.addEventListener('click', () => {
            isDrawing = true;
            drawnPoints = [];
            statusElement.textContent = '正在绘制轨迹，请在画布上拖动鼠标...';

            // 添加鼠标事件
            canvas.addEventListener('mousedown', onDrawStart);
            canvas.addEventListener('mousemove', onDraw);
            canvas.addEventListener('mouseup', onDrawEnd);
            canvas.addEventListener('mouseleave', onDrawEnd);

            // 添加触摸事件支持
            canvas.addEventListener('touchstart', onTouchStart);
            canvas.addEventListener('touchmove', onTouchMove);
            canvas.addEventListener('touchend', onTouchEnd);

            startButton.disabled = true;
            resetButton.disabled = true;
            drawButton.disabled = true;
            clearButton.disabled = false;

            // 更新状态显示
            systemStatusElement.textContent = '绘制轨迹中';
            systemStatusElement.className = 'font-medium text-amber-500';
        });

        function onDrawStart(event) {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            drawnPoints.push([x, y]);
        }

        function onDraw(event) {
            if (isDrawing) {
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                if (drawnPoints.length > 0) {
                    const lastPoint = drawnPoints[drawnPoints.length - 1];
                    const distance = Math.sqrt((x - lastPoint[0]) ** 2 + (y - lastPoint[1]) ** 2);
                    if (distance < 10) {
                        return;
                    }
                }
                drawnPoints.push([x, y]);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.beginPath();
                ctx.moveTo(drawnPoints[0][0], drawnPoints[0][1]);
                for (let i = 1; i < drawnPoints.length; i++) {
                    ctx.lineTo(drawnPoints[i][0], drawnPoints[i][1]);
                }
                ctx.strokeStyle = '#10B981'; // 使用Tailwind的secondary颜色
                ctx.lineWidth = 3;
                ctx.stroke();
            }
        }

        function onDrawEnd() {
            isDrawing = false;
            canvas.removeEventListener('mousedown', onDrawStart);
            canvas.removeEventListener('mousemove', onDraw);
            canvas.removeEventListener('mouseup', onDrawEnd);
            canvas.removeEventListener('mouseleave', onDrawEnd);
            canvas.removeEventListener('touchstart', onTouchStart);
            canvas.removeEventListener('touchmove', onTouchMove);
            canvas.removeEventListener('touchend', onTouchEnd);

            if (drawnPoints.length > 1) {
                const result = simulation.setTrajectory(drawnPoints);
                statusElement.textContent = result.message;
                startButton.disabled = false;
                resetButton.disabled = false;
                drawButton.disabled = false;

                // 保存原轨迹图像
                originalTrajectoryImage = ctx.getImageData(0, 0, canvas.width, canvas.height);
                combinedImage = originalTrajectoryImage;
                isFirstRun = true;

                // 更新状态显示
                systemStatusElement.textContent = '准备就绪';
                systemStatusElement.className = 'font-medium text-green-500';
            } else {
                statusElement.textContent = '未绘制有效轨迹，请重新绘制';
                drawButton.disabled = false;

                // 更新状态显示
                systemStatusElement.textContent = '错误';
                systemStatusElement.className = 'font-medium text-red-500';
            }
        }

        // 触摸事件处理
        function onTouchStart(event) {
            event.preventDefault(); // 防止页面滚动
            const touchPos = getTouchPosition(event);
            if (touchPos) {
                drawnPoints.push([touchPos.x, touchPos.y]);
            }
        }

        function onTouchMove(event) {
            event.preventDefault(); // 防止页面滚动
            if (isDrawing) {
                const touchPos = getTouchPosition(event);
                if (touchPos && drawnPoints.length > 0) {
                    const lastPoint = drawnPoints[drawnPoints.length - 1];
                    const distance = Math.sqrt((touchPos.x - lastPoint[0]) ** 2 + (touchPos.y - lastPoint[1]) ** 2);
                    if (distance < 10) {
                        return;
                    }

                    drawnPoints.push([touchPos.x, touchPos.y]);
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.beginPath();
                    ctx.moveTo(drawnPoints[0][0], drawnPoints[0][1]);
                    for (let i = 1; i < drawnPoints.length; i++) {
                        ctx.lineTo(drawnPoints[i][0], drawnPoints[i][1]);
                    }
                    ctx.strokeStyle = '#10B981'; // 使用Tailwind的secondary颜色
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
            }
        }

        function onTouchEnd(event) {
            event.preventDefault();
            onDrawEnd();
        }

        clearButton.addEventListener('click', () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawnPoints = [];
            startButton.disabled = true;
            resetButton.disabled = true;
            clearButton.disabled = true;
            statusElement.textContent = '轨迹已清除，请重新绘制';
            originalTrajectoryImage = null;
            combinedImage = null;
            isFirstRun = true;

            // 更新状态显示
            systemStatusElement.textContent = '准备就绪';
            systemStatusElement.className = 'font-medium text-green-500';
            currentPositionElement.textContent = '--, --';
            currentDirectionElement.textContent = '0°';
            progressBarElement.style.width = '0%';
            progressTextElement.textContent = '0%';
        });

        startButton.addEventListener('click', () => {
            const result = simulation.startSimulation();
            statusElement.textContent = result.message;
            startButton.disabled = true;
            pauseButton.disabled = false;
            if (!intervalId) {
                intervalId = setInterval(updateStatus, 100);
            }

            // 更新状态显示
            systemStatusElement.textContent = '运行中';
            systemStatusElement.className = 'font-medium text-blue-500';
        });

        pauseButton.addEventListener('click', () => {
            const result = simulation.pauseSimulation();
            statusElement.textContent = result.message;
            startButton.disabled = false;
            pauseButton.disabled = true;

            // 更新状态显示
            systemStatusElement.textContent = '已暂停';
            systemStatusElement.className = 'font-medium text-amber-500';
        });

        resetButton.addEventListener('click', () => {
            const result = simulation.resetSimulation();
            statusElement.textContent = result.message;
            startButton.disabled = false;
            pauseButton.disabled = true;
            clearInterval(intervalId);
            intervalId = null;

            // 重置时清除所有轨迹
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (originalTrajectoryImage) {
                ctx.putImageData(originalTrajectoryImage, 0, 0);
            }
            combinedImage = originalTrajectoryImage;
            isFirstRun = true;

            // 更新状态显示
            systemStatusElement.textContent = '准备就绪';
            systemStatusElement.className = 'font-medium text-green-500';
            currentPositionElement.textContent = '--, --';
            currentDirectionElement.textContent = '0°';
            progressBarElement.style.width = '0%';
            progressTextElement.textContent = '0%';
        });

        applyParamsButton.addEventListener('click', () => {
            const kp = document.getElementById('kp').value;
            const kd = document.getElementById('kd').value;
            const speed = document.getElementById('speed').value;
            const viewDistance = document.getElementById('viewDistance').value;

            const result = simulation.updateParams({
                kp: kp,
                kd: kd,
                speed: speed,
                viewDistance: viewDistance
            });

            statusElement.textContent = result.message +
                ` (Kp=${kp}, Kd=${kd}, 速度=${speed}, 视野=${viewDistance})`;

            // 更新状态显示
            systemStatusElement.textContent = '参数已更新';
            systemStatusElement.className = 'font-medium text-green-500';
        });

        // 绘制小车函数（包含视野范围）
        function drawCar(x, y, direction, viewDistance) {
            // 绘制视野范围
            viewDistance = viewDistance * 20; // 放大视野范围以便更好显示
            ctx.beginPath();
            ctx.arc(x, y, viewDistance, 0, 2 * Math.PI);
            ctx.strokeStyle = 'rgba(59, 130, 246, 0.2)'; // 使用Tailwind的primary颜色
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.fillStyle = 'rgba(59, 130, 246, 0.1)';
            ctx.fill();

            // 绘制小车
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(direction);

            // 绘制小车主体（三角形）
            ctx.beginPath();
            ctx.moveTo(CAR_SIZE, 0);
            ctx.lineTo(-CAR_SIZE/2, CAR_SIZE/2);
            ctx.lineTo(-CAR_SIZE/2, -CAR_SIZE/2);
            ctx.closePath();

            ctx.fillStyle = '#EF4444'; // 使用Tailwind的red-500颜色
            ctx.fill();
            ctx.strokeStyle = '#DC2626'; // 使用Tailwind的red-600颜色
            ctx.lineWidth = 2;
            ctx.stroke();

            // 绘制小车方向指示器
            ctx.beginPath();
            ctx.moveTo(CAR_SIZE, 0);
            ctx.lineTo(CAR_SIZE - 5, -3);
            ctx.lineTo(CAR_SIZE - 5, 3);
            ctx.closePath();
            ctx.fillStyle = '#DC2626';
            ctx.fill();

            ctx.restore();
        }

        function updateStatus() {
            const status = simulation.getStatus();

            // 更新状态显示
            if (status.status === 'running') {
                systemStatusElement.textContent = '运行中';
                systemStatusElement.className = 'font-medium text-blue-500';
            } else {
                systemStatusElement.textContent = '已完成';
                systemStatusElement.className = 'font-medium text-green-500';
            }

            if (status.position) {
                currentPositionElement.textContent = `${Math.round(status.position[0])}, ${Math.round(status.position[1])}`;
                currentDirectionElement.textContent = `${Math.round(status.direction * 180 / Math.PI)}°`;
            }

            progressBarElement.style.width = `${status.progress}%`;
            progressTextElement.textContent = `${status.progress}%`;

            // 绘制原轨迹
            if (originalTrajectoryImage) {
                ctx.putImageData(originalTrajectoryImage, 0, 0);
            }

            // 绘制小车轨迹
            if (status.trajectoryX.length > 0) {
                ctx.beginPath();
                ctx.moveTo(status.trajectoryX[0], status.trajectoryY[0]);
                for (let i = 1; i < status.trajectoryX.length; i++) {
                    ctx.lineTo(status.trajectoryX[i], status.trajectoryY[i]);
                }
                ctx.strokeStyle = '#3B82F6'; // 使用Tailwind的primary颜色
                ctx.lineWidth = 3;
                ctx.stroke();

                // 循迹结束后保存完整轨迹图像
                if (status.status === 'stopped' && isFirstRun) {
                    combinedImage = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    isFirstRun = false;
                }
            }

            // 绘制小车及其视野范围
            if (status.position) {
                drawCar(status.position[0], status.position[1], status.direction, status.viewDistance);
            }

            // 循迹结束后显示完整轨迹
            if (status.status === 'stopped' && combinedImage) {
                ctx.putImageData(combinedImage, 0, 0);

                // 绘制最后位置的小车及其视野范围
                if (status.position) {
                    drawCar(status.position[0], status.position[1], status.direction, status.viewDistance);
                }
            }
        }
    </script>
</body>
</html>
